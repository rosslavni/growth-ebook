Growth: 全栈工程师学习手册
===

全栈工程师是未来
---

技术在过去的几十年里进步很快，也将在未来的几十年里发展得更快。今天技术的门槛下降得越来越快，原本需要一个团队做出来的Web应用，现在只需要一两个人就可以了。

###技术的变革

在开始进入主题之前，先我们看看历史的进程。

####早期网站架构

二十年前的网站以静态的形式出现，这样的网站并不需要太多的人去维护、管理。接着，人们发明了CGI(通用网关接口，英语：Common Gateway Interface)来实现动态的网站。下图是一个早期网站的架构图：

![CGI网站架构](chapters/prelude/cgi-arch.gif)

当时这种网站的URL类似于：

```bash
https://www.phodal.com/cgi-bin/getblog
```

(PS：这个链接是为了讲解而存在的，并没有真实存在。)

用户访问上面的网页的时候就会访问，cgi-bin的路径下对应的getblog脚本。你可以用Shell返回这个网页：

```bash
#!/bin/sh
echo Content-type: text/plain
echo hello,world
```

也可以用Perl来处理:

```perl
#!/usr/local/bin/perl
print "Content-type: text/plain";
print "helo,world";
```

这时的网站大量的依赖于脚本，如果说有明显的架构模式的话，就是上面那张古老的图。人们将HTML、脚本代码、CSS、SQL语句等等的代码都写在脚本文件里。看起来就像这样的：

```perl
#!/usr/bin/perl
use DBI;

# connect to MySQL...
$driver= "mysql";
$dsn = "DBI:$driver:database=sample;host=csmysql.cs.cf.ac.uk";
$dbh = DBI->connect($dsn, "exampleuser", "passabc");

# prepare and execute the SQL statement
$sth = $dbh->prepare("SELECT s.name, o.osname, p.pname
       FROM systems s, opsystem o, people p
       WHERE s.oscode=o.oscode and s.ownercode = p.pcode");
$sth->execute;

# retrieve the results
print "Name\tOwner\tOperating System\n";
while(  my $ref = $sth->fetchrow_hashref() ) {
	print $ref->{'name'};
	print "\t";
	print $ref->{'pname'};
	print "\t";
	print $ref->{'osname'};
	print "\n";
}
exit;
```

Blabla，各种代码混乱地夹杂在一起。不得不说一句：这样的代码在2012年，我也看了有一些。简单地来说，这个时代的代码结构就是这样的：

![CGI脚本文件 ](chapters/prelude/cgi-script.png)

这简直就是一场恶梦。不过，在今天好似那些PHP新手也是这样写代码的。

好了，这时候我们就可以讨论讨论MVC模式了。

####MVC模式

我有理由相信Martin Fowler的《企业应用架构模式》在当时一定非常受欢迎。






